# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import ccxt.async_support
from ccxt.async_support.base.ws.cache import ArrayCache, ArrayCacheBySymbolById, ArrayCacheBySymbolBySide, ArrayCacheByTimestamp
from ccxt.base.types import Any, Balances, Int, Liquidation, Num, Order, OrderBook, OrderSide, OrderType, Position, Str, Strings, Ticker, Tickers, Trade
from ccxt.async_support.base.ws.client import Client
from typing import List
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import NotSupported
from ccxt.base.errors import ChecksumError
from ccxt.base.precise import Precise


class lighter(ccxt.async_support.lighter):

    def describe(self) -> Any:
        superDescribe = super(lighter, self).describe()
        return self.deep_extend(superDescribe, self.describe_data())

    def describe_data(self):
        return {
            'has': {
                'ws': True,
                'watchBalance': False,  # Not implemented yet
                'watchBidsAsks': True,
                'watchMyTrades': False,  # Requires authentication
                'watchOHLCV': True,
                'watchOHLCVForSymbols': True,
                'watchOrderBook': True,
                'watchOrderBookForSymbols': True,
                'watchOrders': False,  # Requires authentication
                'watchOrdersForSymbols': False,  # Requires authentication
                'watchPositions': False,  # Requires authentication
                'watchTicker': True,
                'watchTickers': True,
                'watchTrades': True,
                'watchTradesForSymbols': True,
                'createOrderWs': False,  # Not implemented yet
                'editOrderWs': False,  # Not implemented yet
                'cancelOrderWs': False,  # Not implemented yet
            },
            'urls': {
                'api': {
                    'ws': 'wss://mainnet.zklighter.elliot.ai/ws',
                },
            },
            'options': {
                'ws': {
                    'cost': 1,
                },
            },
        }

    async def watch_ticker(self, symbol: str, params={}):
        """
        Watch ticker updates for a symbol
        """
        await self.load_markets()
        market = self.market(symbol)
        messageHash = 'ticker:' + market['id']
        url = self.urls['api']['ws']
        request = {
            'method': 'SUBSCRIBE',
            'params': [market['id'] + '@ticker'],
            'id': self.request_id(),
        }
        return await self.watch(url, messageHash, request, messageHash)

    async def watch_tickers(self, symbols: Strings = None, params={}):
        """
        Watch ticker updates for multiple symbols
        """
        await self.load_markets()
        symbols = self.market_symbols(symbols)
        messageHash = 'tickers'
        url = self.urls['api']['ws']
        
        streams = []
        for symbol in symbols:
            market = self.market(symbol)
            streams.append(market['id'] + '@ticker')
        
        request = {
            'method': 'SUBSCRIBE',
            'params': streams,
            'id': self.request_id(),
        }
        return await self.watch(url, messageHash, request, messageHash)

    async def watch_order_book(self, symbol: str, limit: Int = None, params={}):
        """
        Watch order book updates for a symbol
        """
        await self.load_markets()
        market = self.market(symbol)
        messageHash = 'orderbook:' + market['id']
        url = self.urls['api']['ws']
        
        stream = market['id'] + '@depth'
        if limit is not None:
            stream += str(limit)
        
        request = {
            'method': 'SUBSCRIBE',
            'params': [stream],
            'id': self.request_id(),
        }
        return await self.watch(url, messageHash, request, messageHash)

    async def watch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}):
        """
        Watch trade updates for a symbol
        """
        await self.load_markets()
        market = self.market(symbol)
        messageHash = 'trades:' + market['id']
        url = self.urls['api']['ws']
        request = {
            'method': 'SUBSCRIBE',
            'params': [market['id'] + '@trade'],
            'id': self.request_id(),
        }
        return await self.watch(url, messageHash, request, messageHash)

    async def watch_ohlcv(self, symbol: str, timeframe='1m', since: Int = None, limit: Int = None, params={}):
        """
        Watch OHLCV candlestick updates for a symbol
        """
        await self.load_markets()
        market = self.market(symbol)
        interval = self.timeframes[timeframe]
        messageHash = 'ohlcv:' + market['id'] + ':' + timeframe
        url = self.urls['api']['ws']
        request = {
            'method': 'SUBSCRIBE',
            'params': [market['id'] + '@kline_' + interval],
            'id': self.request_id(),
        }
        return await self.watch(url, messageHash, request, messageHash)

    def handle_message(self, client: Client, message):
        """
        Handle incoming WebSocket messages
        """
        if 'stream' in message:
            stream = message['stream']
            data = message['data']
            
            if '@ticker' in stream:
                self.handle_ticker(client, data, stream)
            elif '@depth' in stream:
                self.handle_order_book(client, data, stream)
            elif '@trade' in stream:
                self.handle_trades(client, data, stream)
            elif '@kline' in stream:
                self.handle_ohlcv(client, data, stream)
        
        return message

    def handle_ticker(self, client: Client, ticker, stream):
        """
        Handle ticker updates
        """
        marketId = stream.split('@')[0]
        market = self.safe_market(marketId)
        symbol = market['symbol']
        
        parsed = self.parse_ws_ticker(ticker, market)
        messageHash = 'ticker:' + marketId
        
        self.tickers[symbol] = parsed
        client.resolve(parsed, messageHash)

    def handle_order_book(self, client: Client, orderbook, stream):
        """
        Handle order book updates
        """
        marketId = stream.split('@')[0]
        market = self.safe_market(marketId)
        symbol = market['symbol']
        
        if symbol not in self.orderbooks:
            self.orderbooks[symbol] = self.order_book()
        
        ob = self.orderbooks[symbol]
        parsed = self.parse_ws_order_book(orderbook, symbol)
        
        ob['bids'] = parsed['bids']
        ob['asks'] = parsed['asks']
        ob['timestamp'] = parsed['timestamp']
        ob['datetime'] = parsed['datetime']
        
        messageHash = 'orderbook:' + marketId
        client.resolve(ob, messageHash)

    def handle_trades(self, client: Client, trades, stream):
        """
        Handle trade updates
        """
        marketId = stream.split('@')[0]
        market = self.safe_market(marketId)
        symbol = market['symbol']
        
        if symbol not in self.trades:
            self.trades[symbol] = ArrayCache()
        
        tradesArray = self.trades[symbol]
        
        if isinstance(trades, list):
            for trade in trades:
                parsed = self.parse_ws_trade(trade, market)
                tradesArray.append(parsed)
        else:
            parsed = self.parse_ws_trade(trades, market)
            tradesArray.append(parsed)
        
        messageHash = 'trades:' + marketId
        client.resolve(tradesArray, messageHash)

    def handle_ohlcv(self, client: Client, kline, stream):
        """
        Handle OHLCV updates
        """
        parts = stream.split('@')
        marketId = parts[0]
        interval = parts[1].replace('kline_', '')
        
        market = self.safe_market(marketId)
        symbol = market['symbol']
        timeframe = self.find_timeframe(interval)
        
        parsed = self.parse_ws_ohlcv(kline, market)
        
        if symbol not in self.ohlcvs:
            self.ohlcvs[symbol] = {}
        if timeframe not in self.ohlcvs[symbol]:
            self.ohlcvs[symbol][timeframe] = ArrayCacheByTimestamp()
        
        ohlcvs = self.ohlcvs[symbol][timeframe]
        ohlcvs.append(parsed)
        
        messageHash = 'ohlcv:' + marketId + ':' + timeframe
        client.resolve(ohlcvs, messageHash)

    def parse_ws_ticker(self, ticker, market=None):
        """
        Parse WebSocket ticker data
        """
        return self.parse_ticker(ticker, market)

    def parse_ws_order_book(self, orderbook, symbol, timestamp=None):
        """
        Parse WebSocket order book data
        """
        return self.parse_order_book(orderbook, symbol, timestamp)

    def parse_ws_trade(self, trade, market=None):
        """
        Parse WebSocket trade data
        """
        return self.parse_trade(trade, market)

    def parse_ws_ohlcv(self, ohlcv, market=None):
        """
        Parse WebSocket OHLCV data
        """
        return self.parse_ohlcv(ohlcv, market)

    def request_id(self):
        """
        Generate request ID for WebSocket messages
        """
        return self.milliseconds()
