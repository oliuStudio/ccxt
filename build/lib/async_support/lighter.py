# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
from ccxt.abstract.lighter import ImplicitAPI
import math
from ccxt.base.types import Any, Balances, Currencies, Currency, Int, LedgerEntry, MarginModification, Market, Num, Order, OrderBook, OrderRequest, CancellationRequest, OrderSide, OrderType, Position, Str, Strings, Ticker, Tickers, FundingRate, FundingRates, Trade, TradingFeeInterface, Transaction, MarketInterface, TransferEntry
from typing import List
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import NotSupported
from ccxt.base.decimal_to_precision import ROUND
from ccxt.base.decimal_to_precision import DECIMAL_PLACES
from ccxt.base.decimal_to_precision import SIGNIFICANT_DIGITS
from ccxt.base.decimal_to_precision import TICK_SIZE
from ccxt.base.precise import Precise


class lighter(Exchange, ImplicitAPI):

    def describe(self) -> Any:
        return self.deep_extend(super(lighter, self).describe(), {
            'id': 'lighter',
            'name': 'Lighter',
            'countries': [],
            'version': 'v1',
            'rateLimit': 100,
            'certified': False,
            'pro': True,
            'dex': True,
            'has': {
                'CORS': None,
                'spot': True,
                'margin': False,
                'swap': True,
                'future': True,
                'option': False,
                'addMargin': False,
                'borrowCrossMargin': False,
                'borrowIsolatedMargin': False,
                'cancelAllOrders': True,
                'cancelAllOrdersAfter': False,
                'cancelOrder': True,
                'cancelOrders': False,
                'createDepositAddress': False,
                'createLimitBuyOrder': True,
                'createLimitSellOrder': True,
                'createMarketBuyOrder': True,
                'createMarketSellOrder': True,
                'createOrder': True,
                'createOrderWithTakeProfitAndStopLoss': False,
                'createPostOnlyOrder': True,
                'createReduceOnlyOrder': True,
                'createStopLimitOrder': False,
                'createStopMarketOrder': False,
                'createStopOrder': False,
                'createTriggerOrder': False,
                'editOrder': False,
                'fetchBalance': True,
                'fetchBidsAsks': False,
                'fetchCanceledOrders': False,
                'fetchClosedOrder': False,
                'fetchClosedOrders': False,
                'fetchCurrencies': False,
                'fetchDepositAddress': False,
                'fetchDeposits': False,
                'fetchFundingHistory': False,
                'fetchFundingRate': False,
                'fetchFundingRateHistory': False,
                'fetchFundingRates': False,
                'fetchIndexOHLCV': False,
                'fetchLedger': False,
                'fetchLeverageTiers': False,
                'fetchMarkets': True,
                'fetchMarkOHLCV': False,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenOrder': False,
                'fetchOpenOrders': True,
                'fetchOrder': False,
                'fetchOrderBook': True,
                'fetchOrders': False,
                'fetchOrderTrades': False,
                'fetchPosition': False,
                'fetchPositions': True,
                'fetchPremiumIndexOHLCV': False,
                'fetchStatus': True,
                'fetchTicker': True,
                'fetchTickers': False,
                'fetchTime': False,
                'fetchTrades': True,
                'fetchTradingFee': False,
                'fetchTradingFees': False,
                'fetchTransactions': False,
                'fetchTransfers': False,
                'fetchWithdrawals': False,
                'reduceMargin': False,
                'setLeverage': False,
                'setMarginMode': False,
                'setPositionMode': False,
                'signIn': False,
                'transfer': False,
                'withdraw': False,
            },
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '4h': '4h',
                '1d': '1d',
                '1w': '1w',
            },
            'urls': {
                'logo': 'https://lighter.xyz/logo.png',
                'api': {
                    'public': 'https://mainnet.zklighter.elliot.ai',
                    'private': 'https://mainnet.zklighter.elliot.ai',
                },
                'www': 'https://lighter.xyz',
                'doc': [
                    'https://docs.lighter.xyz',
                ],
                'fees': 'https://docs.lighter.xyz/fees',
            },
            'api': {
                'public': {
                    'get': {
                        'info/status': 1,
                        'info/markets': 1,
                        'info/ticker': 1,
                        'info/orderbook': 1,
                        'info/trades': 1,
                        'candlestick/candlesticks': 1,
                    },
                },
                'private': {
                    'get': {
                        'account/account': 1,
                        'account/positions': 1,
                        'account/orders': 1,
                        'account/trades': 1,
                    },
                    'post': {
                        'order/create': 1,
                        'order/cancel': 1,
                        'order/cancel-all': 1,
                    },
                },
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'maker': self.parse_number('0.0002'),
                    'taker': self.parse_number('0.0005'),
                },
            },
            'precisionMode': TICK_SIZE,
            'exceptions': {
                'exact': {},
                'broad': {},
            },
        })

    async def fetch_markets(self, params={}):
        response = await self.publicGetInfoMarkets(params)
        return self.parse_markets(response)

    def parse_markets(self, markets):
        result = []
        for market in markets:
            result.append(self.parse_market(market))
        return result

    def parse_market(self, market):
        id = self.safe_string(market, 'id')
        baseId = self.safe_string(market, 'base_asset')
        quoteId = self.safe_string(market, 'quote_asset')
        base = self.safe_currency_code(baseId)
        quote = self.safe_currency_code(quoteId)
        symbol = base + '/' + quote
        
        return {
            'id': id,
            'symbol': symbol,
            'base': base,
            'quote': quote,
            'settle': None,
            'baseId': baseId,
            'quoteId': quoteId,
            'settleId': None,
            'type': 'spot',
            'spot': True,
            'margin': False,
            'swap': False,
            'future': False,
            'option': False,
            'active': True,
            'contract': False,
            'linear': None,
            'inverse': None,
            'contractSize': None,
            'expiry': None,
            'expiryDatetime': None,
            'strike': None,
            'optionType': None,
            'precision': {
                'amount': self.safe_number(market, 'amount_precision'),
                'price': self.safe_number(market, 'price_precision'),
            },
            'limits': {
                'leverage': {
                    'min': None,
                    'max': None,
                },
                'amount': {
                    'min': self.safe_number(market, 'min_order_size'),
                    'max': self.safe_number(market, 'max_order_size'),
                },
                'price': {
                    'min': None,
                    'max': None,
                },
                'cost': {
                    'min': None,
                    'max': None,
                },
            },
            'info': market,
        }

    async def fetch_ticker(self, symbol: str, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'market_id': market['id'],
        }
        response = await self.publicGetInfoTicker(self.extend(request, params))
        return self.parse_ticker(response, market)

    def parse_ticker(self, ticker, market=None):
        symbol = None
        if market is not None:
            symbol = market['symbol']
        
        timestamp = self.safe_timestamp(ticker, 'timestamp')
        
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_number(ticker, 'high_24h'),
            'low': self.safe_number(ticker, 'low_24h'),
            'bid': self.safe_number(ticker, 'bid'),
            'bidVolume': None,
            'ask': self.safe_number(ticker, 'ask'),
            'askVolume': None,
            'vwap': None,
            'open': self.safe_number(ticker, 'open_24h'),
            'close': self.safe_number(ticker, 'last_price'),
            'last': self.safe_number(ticker, 'last_price'),
            'previousClose': None,
            'change': self.safe_number(ticker, 'price_change_24h'),
            'percentage': self.safe_number(ticker, 'price_change_percent_24h'),
            'average': None,
            'baseVolume': self.safe_number(ticker, 'volume_24h'),
            'quoteVolume': self.safe_number(ticker, 'quote_volume_24h'),
            'info': ticker,
        }

    async def fetch_order_book(self, symbol: str, limit: Int = None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'market_id': market['id'],
        }
        if limit is not None:
            request['limit'] = limit
        
        response = await self.publicGetInfoOrderbook(self.extend(request, params))
        return self.parse_order_book(response, symbol)

    def parse_order_book(self, orderbook, symbol, timestamp=None, bidsKey='bids', asksKey='asks', priceKey=0, amountKey=1):
        bids = self.safe_value(orderbook, bidsKey, [])
        asks = self.safe_value(orderbook, asksKey, [])
        
        return {
            'symbol': symbol,
            'bids': self.sort_by(bids, 0, True),
            'asks': self.sort_by(asks, 0),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp) if timestamp else None,
            'nonce': None,
        }

    async def fetch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'market_id': market['id'],
        }
        if limit is not None:
            request['limit'] = limit
        
        response = await self.publicGetInfoTrades(self.extend(request, params))
        return self.parse_trades(response, market, since, limit)

    def parse_trade(self, trade, market=None):
        timestamp = self.safe_timestamp(trade, 'timestamp')
        symbol = None
        if market is not None:
            symbol = market['symbol']
        
        return {
            'id': self.safe_string(trade, 'id'),
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'order': None,
            'type': None,
            'side': self.safe_string(trade, 'side'),
            'amount': self.safe_number(trade, 'size'),
            'price': self.safe_number(trade, 'price'),
            'cost': None,
            'fee': None,
        }

    async def fetch_ohlcv(self, symbol: str, timeframe='1h', since: Int = None, limit: Int = None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'market_id': market['id'],
            'resolution': self.timeframes[timeframe],
        }
        if since is not None:
            request['start_timestamp'] = int(since / 1000)
        if limit is not None:
            request['count_back'] = limit
        
        response = await self.publicGetCandlestickCandlesticks(self.extend(request, params))
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    def parse_ohlcv(self, ohlcv, market=None):
        return [
            self.safe_timestamp(ohlcv, 'timestamp'),
            self.safe_number(ohlcv, 'open'),
            self.safe_number(ohlcv, 'high'),
            self.safe_number(ohlcv, 'low'),
            self.safe_number(ohlcv, 'close'),
            self.safe_number(ohlcv, 'volume'),
        ]

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api'][api] + '/' + path
        
        if api == 'public':
            if params:
                url += '?' + self.urlencode(params)
        else:
            raise NotSupported(self.id + ' private API authentication not implemented yet')
        
        headers = {} if headers is None else headers
        headers['Content-Type'] = 'application/json'
        
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return
        
        error = self.safe_string(response, 'error')
        if error is not None:
            raise ExchangeError(self.id + ' ' + error)
